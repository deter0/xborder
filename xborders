#!/bin/python3
import cairo

import gi

gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
gi.require_version("Wnck", "3.0")
gi.require_version("GObject", "2.0")

from gi.repository import Gtk, Gdk, Wnck, GObject, GLib 

import re
import subprocess
import sys
import argparse
import json
import time

BORDER_RADIUS = 14
BORDER_WIDTH = 4
BORDER_R = 123
BORDER_G = 88
BORDER_B = 220
BORDER_A = 1
BORDERED_WINDOW = None

def set_border_rgba(args):
    literal_value = 0
    try:
        literal_value = int(args.border_rgba.replace("#", "0x"), 16)
    except:
        print(
            f"`{args.border_rgba}` is an invalid hexadecimal number!",
            file=sys.stderr,
        )
        sys.exit(1)
    args.border_red = literal_value >> (3 * 8) & 0xFF
    args.border_green = literal_value >> (2 * 8) & 0xFF
    args.border_blue = literal_value >> (1 * 8) & 0xFF
    args.border_alpha = (literal_value >> (0 * 8) & 0xFF) / 255  # map from 0 to 1


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
            "--config", "-c", 
            type=str, 
            help="The path to the config file"
    )
    parser.add_argument(
        "--border-radius", 
        type=int, 
        default=14, 
        help="The border radius, in pixels"
    )
    parser.add_argument(
        "--border-width", 
        type=int, 
        default=4, 
        help="The border width in pixels"
    )
    parser.add_argument(
        "--border-red",
        type=int,
        default=123,
        help="The border's red value, between 0 and 255",
    )
    parser.add_argument(
        "--border-green",
        type=int,
        default=88,
        help="The border's green value, between 0 and 255",
    )
    parser.add_argument(
        "--border-blue",
        type=int,
        default=220,
        help="The border's blue value, between 0 and 255",
    )
    parser.add_argument(
        "--border-alpha",
        type=float,
        default=1,
        help="The border's alpha value, between zero and 1",
    )
    parser.add_argument(
        "--border-rgba",
        default=None,
        help="The colours of the border in hex format, example: #FF0000FF",
    )
    parser.add_argument(
        "--border-mode",
        type=str,
        default="outside",
        help="Whether to place the border on the outside, inside or in the center of windows. Values are `outside`, `inside`, `center`"
    )
    args = parser.parse_args()
    if args.border_rgba is not None:
        set_border_rgba(args)

    # Extract the literal values
    if args.config is not None:
        with open(args.config, "r") as f:
            raw = f.read().replace("-", "_")
            dat = json.loads(raw)
            for ident in dat:
                if ident == "border_rgba":
                    args.border_rgba = dat[ident]
                    set_border_rgba(args)
                else:
                    args.__dict__[ident] = dat[
                        ident
                    ]  # Idea gotten from here: https://stackoverflow.com/a/1325798

    global BORDER_RADIUS
    global BORDER_WIDTH
    global BORDER_MODE
    global BORDER_R
    global BORDER_G
    global BORDER_B
    global BORDER_A

    BORDER_RADIUS = args.border_radius
    BORDER_WIDTH = args.border_width
    BORDER_R = args.border_red
    BORDER_G = args.border_green
    BORDER_B = args.border_blue
    BORDER_A = args.border_alpha
    if args.border_mode == "inside":
        BORDER_MODE = 0
    elif args.border_mode == "outside":
        BORDER_MODE = 1
    elif args.border_mode == "center":
        BORDER_MODE = 2
    else:
        raise ValueError(f"Invalid border_mode: '{args.border_mode}'.")

    return

def get_screen_size(display): # TODO: Multiple monitor size support
    mon_geoms = [display.get_monitor(i).get_geometry() for i in range(display.get_n_monitors())]

    x0 = min(r.x for r in mon_geoms)
    y0 = min(r.y for r in mon_geoms)
    x1 = max(r.x + r.width for r in mon_geoms)
    y1 = max(r.y + r.height for r in mon_geoms)

    return x1 - x0, y1 - y0


class Highlight(Gtk.Window):
    def __init__(self, screen_width, screen_height):
        super().__init__(type=Gtk.WindowType.POPUP)

        self.wnck_screen = Wnck.Screen.get_default()
        self.set_app_paintable(True)
        self.screen = self.get_screen()
        visual = self.screen.get_rgba_visual()
        self.set_visual(visual)

        # As described here: https://docs.gtk.org/gtk3/method.Window.set_wmclass.html
        # Picom blur exclusion would be:
        # "role   = 'xborder'",
        self.set_role("xborder")

        self.resize(screen_width, screen_height)
        self.move(0, 0)

        self.fullscreen()
        self.set_decorated(False)
        self.set_skip_taskbar_hint(True)
        self.set_skip_pager_hint(True)
        self.set_keep_above(True)
        self.set_type_hint(Gdk.WindowTypeHint.NOTIFICATION)

        self.set_accept_focus(False)
        self.set_focus_on_map(False)

        self.drawingarea = Gtk.DrawingArea()
        self.drawingarea.set_events(Gdk.EventMask.EXPOSURE_MASK)
        self.add(self.drawingarea)
        self.input_shape_combine_region(cairo.Region())

        self.set_keep_above(True)
        self.set_title("xborders")
        self.show_all()
        self.border_path = [0, 0, 0, 0]

        # Event connection:
        self.connect("draw", self._draw)
        self.connect("destroy", Gtk.main_quit)
        self.wnck_screen.connect("active-window-changed", self._active_window_changed_event)
        self.connect('composited-changed', self._composited_changed_event)
   
    # This triggers every time the window composited state changes.
    # https://docs.gtk.org/gtk3/signal.Widget.composited-changed.html
    def _composited_changed_event(self, arg):
        if self.screen.is_composited():
            self.move(0, 0)
        else:
            self.move(1e6, 1e6)
            subprocess.Popen(["notify-send", "xborder", "xborders requires a compositor. Resuming once a compositor is running."])

    # This event will trigger every active window change, it will queue a
    # border to be drawn and then do nothing.
    # See:
    #    Signals available for the Wnck.Screen class: https://lazka.github.io/pgi-docs/Wnck-3.0/classes/Screen.html#signals
    #    Signals available for the Wnck.Window class: https://lazka.github.io/pgi-docs/Wnck-3.0/classes/Window.html#signals
    def _active_window_changed_event(self, screen, previous_active_window):
        active_window = self.wnck_screen.get_active_window()

        self.border_path = [0, 0, 0, 0]
        if active_window is not None:
            # Find if the window has a 'geometry-changed' event connected.
            signal_id = GObject.signal_lookup('geometry-changed', active_window)
            has_event_connected = GObject.signal_has_handler_pending(active_window, signal_id, 0, False)
            
            # if it doesn't have one.
            if not has_event_connected:
                # Connect it.
                # Has to be done this way in order to not connect an event
                # every time the active window changes, thus, drawing unnecesary frames.
                active_window.connect('geometry-changed', self._geometry_changed_event)

            if active_window.get_state() != Wnck.WindowState.FULLSCREEN:
                self._calc_border_geometry(active_window)
        self.queue_draw()

    # This is weird, "window_changed" is not necessarily the active window,
    # it is the window which receives the signal of resizing and is not necessarily
    # the active window, this means the border will get drawn on other windows.
    def _geometry_changed_event(self, window_changed):
        active_window = self.wnck_screen.get_active_window()
        if active_window is None or active_window.get_state() == Wnck.WindowState.FULLSCREEN:
            self.border_path = [0, 0, 0, 0]
        else:
            self._calc_border_geometry(active_window)
        self.queue_draw()

    def _calc_border_geometry(self, window):
        x, y, w, h = window.get_geometry()

        # Center
        self.border_path = [x, y, w, h]

        # Inside
        if BORDER_MODE == 0:
            self.border_path[0] += BORDER_WIDTH / 2
            self.border_path[1] += BORDER_WIDTH / 2
            self.border_path[2] -= BORDER_WIDTH
            self.border_path[3] -= BORDER_WIDTH

        # Outside
        elif BORDER_MODE == 1:
            self.border_path[0] -= BORDER_WIDTH / 2
            self.border_path[1] -= BORDER_WIDTH / 2
            self.border_path[2] += BORDER_WIDTH
            self.border_path[3] += BORDER_WIDTH

    def _draw(self, _wid, ctx):
        ctx.save()
        if self.border_path != [0, 0, 0, 0]:
            x, y, w, h = self.border_path
            if BORDER_WIDTH != 0:
                if BORDER_RADIUS > 0:
                    degrees = 0.017453292519943295 # pi/180
                    ctx.arc(x + w - BORDER_RADIUS, y + BORDER_RADIUS, BORDER_RADIUS, -90 * degrees, 0 * degrees)
                    ctx.arc(x + w - BORDER_RADIUS, y + h - BORDER_RADIUS, BORDER_RADIUS, 0 * degrees, 90 * degrees)
                    ctx.arc(x + BORDER_RADIUS, y + h - BORDER_RADIUS, BORDER_RADIUS, 90 * degrees, 180 * degrees)
                    ctx.arc(x + BORDER_RADIUS, y + BORDER_RADIUS, BORDER_RADIUS, 180 * degrees, 270 * degrees)
                    ctx.close_path()
                else:
                    ctx.rectangle(x, y, w, h)
 
                ctx.set_source_rgba(BORDER_R/255, BORDER_G/255, BORDER_B/255, BORDER_A)
                ctx.set_line_width(BORDER_WIDTH)
                ctx.stroke()
        ctx.restore()

def main():
    get_args()
    root = Gdk.get_default_root_window()
    screen = root.get_screen()
    screen_width, screen_height = get_screen_size(Gdk.Display.get_default())

    win = Highlight(screen_width, screen_height)
    Gtk.main()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        exit(0)

else:
    print("This program is not meant to be imported to other Python modules. Please run xborders as a standalone script!")
